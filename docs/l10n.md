다국어 적용 지침:
- 본 문서는 영어, 한국어, 일본어, 중국어 등의 다국어를 지원하기 위한 지침을 제공합니다.
- 다국어 적용을 할 때에는 반드시 본 지침을 준수해야 합니다.

# 다국어 적용 개요

1. 다국어 지원을 위해 Next-Intl 4.0 라이브러리를 사용합니다.
2. 지원 언어: 영어(en), 한국어(ko), 일본어(ja), 중국어(zh)
3. 공식 문서 참고:
   - https://next-intl.dev/docs/getting-started/app-router
   - https://next-intl.dev/docs/usage/translations
   - https://next-intl.dev/docs/usage/numbers
   - https://next-intl.dev/docs/usage/dates-times
   - https://next-intl.dev/docs/usage/lists
   - https://next-intl.dev/docs/usage/configuration
   - https://next-intl.dev/docs/routing/setup
   - https://next-intl.dev/docs/routing/configuration
   - https://github.com/amannn/next-intl

---

## 목차
- [공식 문서 요약](#공식-문서-요약)
- [본 프로젝트 라우팅 전략](#본-프로젝트-라우팅-전략) ⭐ **필수 확인**
- [1. 설치 및 초기 설정](#1-설치-및-초기-설정)
- [2. 디렉토리 구조](#2-디렉토리-구조)
- [3. Cookie-based 라우팅 설정 (localePrefix: 'never')](#3-cookie-based-라우팅-설정-localeprefix-never)
- [4. 언어 스위처 구현 (쿠키 기반)](#4-언어-스위처-구현-쿠키-기반)
- [5. 캐시 환경 주의사항](#5-캐시-환경-주의사항)
- [6. 동작 흐름](#6-동작-흐름)
- [7. 번역 사용법](#7-번역-사용법)
- [8. 숫자 포맷팅](#8-숫자-포맷팅)
- [9. 날짜/시간 포맷팅](#9-날짜시간-포맷팅)
- [10. 리스트 포맷팅](#10-리스트-포맷팅)
- [11. 본 프로젝트 적용 가이드](#11-본-프로젝트-적용-가이드)
- [Quick Reference](#quick-reference)
- [참고 자료](#참고-자료)

---

## 공식 문서 요약

| 문서 | 핵심 요약 | 프로젝트 적용 메모 |
| --- | --- | --- |
| [Getting Started · App Router](https://next-intl.dev/docs/getting-started/app-router) | `createNextIntlPlugin`으로 Next.js 설정을 확장하고, `getRequestConfig`로 요청 단위 메시지/포맷을 로딩합니다. `NextIntlClientProvider`를 루트 레이아웃에서 감싸 클라이언트 훅이 동작하도록 합니다. | `next.config.ts`에 플러그인을 적용하고 `app/[locale]/layout.tsx`에서 `NextIntlClientProvider`를 사용해 공통 메시지를 전달합니다. |
| [Usage · Translations](https://next-intl.dev/docs/usage/translations) | `useTranslations`, `getTranslations`, `createTranslator`, `useMessages` 등 번역 API를 제공하며, 중첩 키, 변수 삽입, 복수형, 리치 텍스트 처리 방식을 설명합니다. | 서버 컴포넌트에서는 `getTranslations`, 클라이언트에서는 `useTranslations`를 사용하고, 리치 텍스트는 `t.rich`로 처리합니다. 네임스페이스를 분리해 메시지 크기를 최소화합니다. |
| [Usage · Numbers](https://next-intl.dev/docs/usage/numbers) | `useFormatter().number`와 글로벌 `formats` 설정을 통해 통화, 백분율, 분수 자릿수 등을 다국어에 맞게 일관되게 포맷합니다. | `app.config.ts` 등에서 사용하는 가격, 카운트 값에 `format.number`를 적용하고, `price`, `compact` 같은 사전 정의 포맷을 프로젝트 전역에서 재사용합니다. |
| [Usage · Dates & Times](https://next-intl.dev/docs/usage/dates-times) | `useFormatter().dateTime`, `relativeTime`, `time`, `useNow` 훅을 제공하여 시간대 및 상대 시각을 처리하고 자동 업데이트를 지원합니다. | 게시글/채팅 타임스탬프는 `format.relativeTime`과 `useNow`를 활용하고, 고정 포맷은 `formats.dateTime`에 등록해 재사용합니다. |
| [Usage · Lists](https://next-intl.dev/docs/usage/lists) | `format.list`로 and/or 조합, 단순 나열 등 언어별 문법을 적용할 수 있습니다. React 요소를 그대로 전달해도 올바르게 렌더링됩니다. | 포럼 카테고리, 사용자 태그, 관심사 등을 나열할 때 `format.list`를 사용하면 하드코딩된 구두점을 제거할 수 있습니다. |
| [Usage · Configuration](https://next-intl.dev/docs/usage/configuration) | `NextIntlClientProvider` 옵션, `formats`, `defaultTranslationValues`, `timeZone` 등을 조정하는 방법을 제공합니다. | 기본 locale은 `ko`, 시간대는 `Asia/Seoul`을 기본값으로 설정하고, 공통 포맷을 `app/i18n/config.ts` 같은 중앙 파일로 관리합니다. |
| [Routing · Setup](https://next-intl.dev/docs/routing/setup) | `defineRouting`, `createNavigation`, `createMiddleware`를 정의해 로케일 기반 라우팅과 내비게이션 헬퍼를 구성합니다. | `src/i18n/routing.ts`와 `app/navigation.ts`를 생성해 `Link`, `useRouter` 등 내비게이션 유틸을 locale 인지 버전으로 교체하고, 미들웨어를 통해 locale 감지를 활성화합니다. |
| [Routing · Configuration](https://next-intl.dev/docs/routing/configuration) | `localePrefix`, `pathnames`, `localeDetection`, `domains` 등 라우팅 동작을 세밀하게 조정하는 방법을 다룹니다. | 기본 locale는 접두사를 생략(`as-needed`), `/forum/list` 같은 경로는 `pathnames`로 선언하여 정적인 URL 매핑을 유지하고, 서버 사이드에서 필요하면 `localeDetection: false`로 고정합니다. |

---

## 본 프로젝트 라우팅 전략

### ❌ 사용하지 않는 방식

본 프로젝트에서는 다음 방식을 **사용하지 않습니다**:

1. **Prefix-based routing (URL에 로케일 포함)**
   - ❌ `/en/forum/list`
   - ❌ `/ko/forum/list`
   - ❌ `/ja/about-us`

2. **Domain-based routing (도메인별 언어 분리)**
   - ❌ `en.vibers.kr/forum/list`
   - ❌ `ko.vibers.kr/forum/list`

### ✅ 본 프로젝트 방식: Cookie-based Locale Detection

**핵심 개념:**
- **URL은 항상 고정**: `/forum/list`, `/about-us` (locale 접두사 없음)
- **로케일 저장소**: NEXT_LOCALE 쿠키
- **전략**: `localePrefix: 'never'`

**로케일 감지 순서:**
1. 🍪 **NEXT_LOCALE 쿠키** (최우선)
   - 사용자가 명시적으로 선택한 언어
   - 1년간 유지
2. 🌐 **Accept-Language 헤더**
   - 브라우저 언어 설정
   - 첫 방문 시 자동 감지
3. 🇰🇷 **defaultLocale('ko')**
   - 위 두 가지 모두 없을 경우 기본값

### 장단점

**✅ 장점:**
- **URL 일관성 유지**: 언어와 무관하게 동일한 URL 구조
- **언어 전환 간편**: URL 변경 없이 쿠키만 수정
- **SEO 설정 단순**: 단일 URL 구조로 관리 용이
- **공유 링크 안정**: 언어 접두사 없어 링크 공유 간편

**❌ 단점:**
- **언어별 URL 인덱싱 불가**: 검색 엔진이 언어별로 URL을 구분할 수 없음
- **공유 링크에 언어 정보 없음**: 링크를 받은 사람은 자신의 브라우저 설정에 따라 언어가 결정됨
- **언어 전환 시 새로고침 필요**: 쿠키 설정 후 페이지를 리로드해야 반영됨

### 사용 예시

**동일한 URL, 다른 언어:**
```
URL: https://www.vibers.kr/forum/list

사용자 A (쿠키: NEXT_LOCALE=ko)  → 한국어로 표시
사용자 B (쿠키: NEXT_LOCALE=en)  → 영어로 표시
사용자 C (쿠키: NEXT_LOCALE=ja)  → 일본어로 표시
사용자 D (쿠키 없음, 브라우저: zh-CN) → 중국어로 표시
```

---

## 1. 설치 및 초기 설정

### 패키지 설치
```bash
npm install next-intl
```

⚠️ **참고**: 본 프로젝트에는 Next-Intl 4.0이 이미 설치되어 있습니다.

### next.config.ts 설정
```typescript
import createNextIntlPlugin from 'next-intl/plugin';

const withNextIntl = createNextIntlPlugin();

export default withNextIntl({
  // 기존 Next.js 설정
});
```

### 루트 레이아웃 구성

`NextIntlClientProvider`는 클라이언트 훅(`useTranslations`, `useFormatter` 등)이 동작할 수 있도록 메시지, locale, 옵션을 전달합니다.

```tsx
// app/[locale]/layout.tsx
import {NextIntlClientProvider} from 'next-intl';
import {notFound} from 'next/navigation';
import {getMessages} from 'next-intl/server';
import {routing} from '@/i18n/routing';

export default async function LocaleLayout({
  children,
  params: {locale},
}: {
  children: React.ReactNode;
  params: {locale: string};
}) {
  if (!routing.locales.includes(locale)) {
    notFound();
  }

  const messages = await getMessages();

  return (
    <html lang={locale}>
      <body>
        <NextIntlClientProvider
          messages={messages}
          locale={locale}
          timeZone="Asia/Seoul"
        >
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
```

> `timeZone`는 [configuration 문서](https://next-intl.dev/docs/usage/configuration)의 권장값을 따라 `Asia/Seoul`을 기본으로 설정하되, 사용자 설정이 있다면 `request.ts`에서 동적으로 주입합니다.

---

## 2. 디렉토리 구조

```
├── messages/               # 번역 파일 디렉토리
│   ├── en.json            # 영어 번역
│   ├── ko.json            # 한국어 번역
│   ├── ja.json            # 일본어 번역
│   └── zh.json            # 중국어 번역
├── src/
│   ├── i18n/
│   │   ├── request.ts     # 요청별 설정 객체 생성
│   │   └── routing.ts     # 라우팅 설정 (지원 언어, 기본 locale)
│   ├── middleware.ts       # locale 감지 및 라우팅
│   └── app/
│       ├── [locale]/      # locale 동적 세그먼트
│       │   ├── layout.tsx # 루트 레이아웃
│       │   └── page.tsx   # 페이지
│       └── navigation.ts  # 라우팅 유틸리티
└── next.config.ts
```

### i18n/request.ts
요청별 설정 객체를 생성하여 locale과 메시지를 제공합니다.

```typescript
import {getRequestConfig} from 'next-intl/server';

export default getRequestConfig(async ({locale}) => {
  return {
    locale,
    messages: (await import(`../../messages/${locale}.json`)).default
  };
});
```

### messages/ko.json 예시
```json
{
  "common": {
    "submit": "전송",
    "cancel": "취소",
    "save": "저장",
    "delete": "삭제"
  },
  "auth": {
    "login": "로그인",
    "signup": "회원가입",
    "logout": "로그아웃"
  },
  "forum": {
    "title": "포럼",
    "createPost": "글쓰기",
    "noPost": "게시글이 없습니다"
  }
}
```

---

## 3. Cookie-based 라우팅 설정 (localePrefix: 'never')

### 3.1 i18n/routing.ts 설정

**파일 경로**: `i18n/routing.ts`

```typescript
import {defineRouting} from 'next-intl/routing';

export const routing = defineRouting({
  locales: ['en', 'ko', 'ja', 'zh'],     // 지원 언어
  defaultLocale: 'ko',                    // 미지원/미지정 시 한국어로 폴백
  localePrefix: 'never'                  // ⭐ 핵심: URL에 로케일 접두어를 절대 붙이지 않음
});
```

**⚠️ 중요:**
- `localePrefix: 'never'`를 사용하면 **쿠키가 로케일의 단일 소스**가 됩니다
- URL은 항상 `/forum/list`, `/about-us` 형식으로 고정됩니다
- 로케일 정보는 NEXT_LOCALE 쿠키에 저장됩니다

### 3.2 middleware.ts 설정

**파일 경로**: `middleware.ts` (프로젝트 루트)

```typescript
import createMiddleware from 'next-intl/middleware';
import {routing} from './i18n/routing';

export default createMiddleware(routing);

// 정적 파일/API를 제외한 모든 경로에 적용
export const config = {
  matcher: ['/((?!api|_next|_vercel|.*\\..*).*)']
};
```

**미들웨어 동작:**
1. **쿠키 확인**: `NEXT_LOCALE` 쿠키가 있는지 먼저 확인
2. **Accept-Language 감지**: 쿠키가 없으면 브라우저의 `Accept-Language` 헤더 확인
3. **기본값 폴백**: 위 두 가지 모두 없으면 `defaultLocale('ko')` 사용
4. **로케일 적용**: 감지된 로케일을 요청 컨텍스트에 설정

**matcher 설정 설명:**
- `/api/*`: API 라우트 제외
- `/_next/*`: Next.js 내부 파일 제외
- `/_vercel/*`: Vercel 시스템 파일 제외
- `.*\\..*`: 정적 파일 (이미지, CSS, JS 등) 제외

### 3.3 app/layout.tsx 설정

**파일 경로**: `app/layout.tsx`

```typescript
import {NextIntlClientProvider} from 'next-intl';
import {getLocale, getMessages} from 'next-intl/server';

export default async function RootLayout({
  children
}: {
  children: React.ReactNode
}) {
  // 미들웨어가 감지한 로케일 가져오기
  const locale = await getLocale();

  // 해당 로케일의 번역 메시지 로드
  const messages = await getMessages();

  return (
    <html lang={locale}>
      <body>
        <NextIntlClientProvider locale={locale} messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
```

**주의사항:**
- `getLocale()`은 미들웨어가 설정한 로케일을 반환합니다
- `getMessages()`는 `i18n/request.ts`에서 정의한 방식대로 메시지를 로드합니다
- `locale`과 `messages`를 `NextIntlClientProvider`에 전달하여 클라이언트 컴포넌트에서 `useTranslations` 등을 사용할 수 있게 합니다

### 3.4 로케일 감지 흐름

```
사용자 요청 → 미들웨어 실행
  ↓
1. NEXT_LOCALE 쿠키 확인
  ├─ 있음 → 해당 로케일 사용
  └─ 없음 → 2단계로
  ↓
2. Accept-Language 헤더 확인
  ├─ ko-KR, ko → 'ko' 사용
  ├─ en-US, en → 'en' 사용
  ├─ ja, ja-JP → 'ja' 사용
  ├─ zh-CN, zh → 'zh' 사용
  └─ 기타 → 3단계로
  ↓
3. defaultLocale 사용 ('ko')
  ↓
로케일 확정 → 레이아웃에서 메시지 로드 → 페이지 렌더링
```

---

## 4. 언어 스위처 구현 (쿠키 기반)

### 4.1 서버 액션으로 쿠키 설정

**파일 경로**: `app/actions/set-locale.ts`

```typescript
'use server';

import {cookies} from 'next/headers';
import {redirect} from 'next/navigation';

export async function setLocale(locale: string, redirectTo: string) {
  // NEXT_LOCALE 쿠키 설정
  cookies().set('NEXT_LOCALE', locale, {
    path: '/',                     // 모든 경로에서 사용
    maxAge: 60 * 60 * 24 * 365    // 1년 보관
  });

  // 현재 페이지로 리다이렉트 (쿠키 적용을 위해 새로고침)
  redirect(redirectTo);
}
```

**왜 서버 액션을 사용하나요?**
- 클라이언트에서 `document.cookie`로 직접 설정하면 엣지 환경에서 누락될 수 있습니다
- 서버 액션 + `redirect()`를 사용하면 쿠키가 확실히 설정되고 미들웨어가 즉시 반영합니다
- Vercel, Cloudflare 등 엣지 플랫폼에서 안전하게 동작합니다

### 4.2 언어 스위처 UI 컴포넌트

**파일 경로**: `components/language-switcher.tsx`

```typescript
'use client';

import {useTransition} from 'react';
import {useLocale} from 'next-intl';
import {setLocale} from '@/app/actions/set-locale';

export function LocaleSwitcher() {
  const currentLocale = useLocale();
  const [isPending, startTransition] = useTransition();

  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const nextLocale = event.target.value;

    // 쿼리스트링과 해시까지 포함해 현재 페이지 유지
    const currentPath = window.location.pathname +
                        window.location.search +
                        window.location.hash;

    // Transition으로 감싸서 부드러운 전환
    startTransition(() => {
      setLocale(nextLocale, currentPath);
    });
  };

  return (
    <select
      value={currentLocale}
      onChange={handleChange}
      disabled={isPending}
      className="px-3 py-2 border border-slate-300 rounded-md bg-white text-sm"
    >
      <option value="ko">한국어</option>
      <option value="en">English</option>
      <option value="ja">日本語</option>
      <option value="zh">中文</option>
    </select>
  );
}
```

**동작 흐름:**
1. 사용자가 언어 선택
2. `setLocale` 서버 액션 호출
3. 서버에서 NEXT_LOCALE 쿠키 설정
4. `redirect()`로 현재 페이지 새로고침
5. 미들웨어가 새 쿠키 읽고 로케일 적용
6. 페이지가 선택한 언어로 렌더링됨

### 4.3 Topbar에 언어 스위처 추가

**파일 경로**: `components/topbar.tsx`

```typescript
import {LocaleSwitcher} from '@/components/language-switcher';

export function Topbar() {
  return (
    <header className="...">
      <nav className="...">
        {/* 기존 네비게이션 */}

        {/* 언어 스위처 추가 */}
        <LocaleSwitcher />
      </nav>
    </header>
  );
}
```

### 4.4 페이지 예시

**파일 경로**: `app/about-us/page.tsx`

```typescript
import {useTranslations} from 'next-intl';

export default function AboutUs() {
  const t = useTranslations('about');

  return (
    <main className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-4">{t('title')}</h1>
      <p className="text-lg text-slate-600">{t('body')}</p>
    </main>
  );
}
```

**messages/ko.json:**
```json
{
  "about": {
    "title": "회사 소개",
    "body": "바이버스는 AI 기반 바이브 코딩으로 실전 웹 애플리케이션을 만드는 커뮤니티입니다."
  }
}
```

**messages/en.json:**
```json
{
  "about": {
    "title": "About Us",
    "body": "Vibers is a community that builds real-world web applications through AI-powered vibe coding."
  }
}
```

**결과:**
- URL: `/about-us` (언어와 무관하게 동일)
- 한국어 쿠키: "회사 소개" + 한글 본문 표시
- 영어 쿠키: "About Us" + 영문 본문 표시

---

## 5. 캐시 환경 주의사항

### 5.1 Vercel/Cloudflare 엣지 환경

**⚠️ 주의사항:**
- `localePrefix: 'never'`를 사용하면 **NEXT_LOCALE 쿠키가 로케일의 단일 소스**가 됩니다
- 엣지 환경(Vercel Edge, Cloudflare Workers)에서 `Set-Cookie` 헤더가 누락될 수 있습니다
- 쿠키가 제대로 설정되지 않으면 사용자가 선택한 언어가 반영되지 않습니다

### 5.2 권장 사항

1. **서버 액션 사용**
   ```typescript
   'use server';
   import {cookies} from 'next/headers';

   export async function setLocale(locale: string) {
     cookies().set('NEXT_LOCALE', locale, {
       path: '/',
       maxAge: 60 * 60 * 24 * 365
     });
   }
   ```

2. **redirect()로 새로고침**
   ```typescript
   import {redirect} from 'next/navigation';

   await setLocale(newLocale);
   redirect(currentPath);  // 쿠키 적용을 위해 새로고침
   ```

3. **클라이언트에서 직접 쿠키 조작 금지**
   ```typescript
   // ❌ 안 좋은 예
   document.cookie = `NEXT_LOCALE=${locale}; path=/; max-age=31536000`;

   // ✅ 좋은 예
   await setLocale(locale, currentPath);  // 서버 액션 사용
   ```

### 5.3 디버깅 방법

**쿠키가 제대로 설정되었는지 확인:**
1. 브라우저 개발자 도구 열기 (F12)
2. Application (또는 Storage) 탭 → Cookies
3. `NEXT_LOCALE` 쿠키 확인
4. 값이 선택한 언어(`ko`, `en`, `ja`, `zh`)인지 확인

**미들웨어가 제대로 작동하는지 확인:**
```typescript
// middleware.ts에 로그 추가 (개발 환경만)
export default createMiddleware({
  ...routing,
  localeDetection(request) {
    console.log('Detected locale:', request.cookies.get('NEXT_LOCALE'));
    return undefined; // 기본 감지 로직 사용
  }
});
```

---

## 6. 동작 흐름

### 6.1 첫 방문 시 (쿠키 없음)

```
사용자 접속 (https://www.vibers.kr/forum/list)
  ↓
[미들웨어 실행]
  ↓
NEXT_LOCALE 쿠키 확인 → 없음
  ↓
Accept-Language 헤더 확인 → ko-KR, ko
  ↓
로케일 설정: 'ko'
  ↓
[레이아웃 렌더링]
  ↓
messages/ko.json 로드
  ↓
[페이지 렌더링]
  ↓
한국어로 표시: "포럼", "글쓰기" 등
```

### 6.2 언어 전환 시

```
사용자가 언어 스위처에서 'English' 선택
  ↓
[클라이언트]
handleChange 이벤트 발생
  ↓
setLocale('en', '/forum/list') 서버 액션 호출
  ↓
[서버]
cookies().set('NEXT_LOCALE', 'en', {path: '/', maxAge: ...})
  ↓
redirect('/forum/list')
  ↓
[미들웨어 재실행]
  ↓
NEXT_LOCALE 쿠키 확인 → 'en'
  ↓
로케일 설정: 'en'
  ↓
[레이아웃 렌더링]
  ↓
messages/en.json 로드
  ↓
[페이지 렌더링]
  ↓
영어로 표시: "Forum", "Write" 등
```

### 6.3 이후 방문 시 (쿠키 있음)

```
사용자 재접속 (https://www.vibers.kr/forum/list)
  ↓
[미들웨어 실행]
  ↓
NEXT_LOCALE 쿠키 확인 → 'en' (이전에 설정한 값)
  ↓
로케일 설정: 'en'
  ↓
[레이아웃 렌더링]
  ↓
messages/en.json 로드
  ↓
[페이지 렌더링]
  ↓
영어로 표시 (사용자가 이전에 선택한 언어 유지)
```

### 6.4 요약

| 시나리오 | NEXT_LOCALE 쿠키 | Accept-Language | 최종 로케일 |
|---------|----------------|-----------------|-----------|
| 첫 방문 (한국) | 없음 | ko-KR | **ko** |
| 첫 방문 (미국) | 없음 | en-US | **en** |
| 첫 방문 (일본) | 없음 | ja | **ja** |
| 언어 전환 후 | en | ko-KR | **en** (쿠키 우선) |
| 재방문 | ko | en-US | **ko** (쿠키 유지) |

---

## 7. 번역 사용법

### useTranslations Hook

**기본 사용법:**
```typescript
import {useTranslations} from 'next-intl';

export default function Component() {
  const t = useTranslations('common');

  return (
    <button>{t('submit')}</button>
  );
}
```

### 중첩된 메시지 구조

**JSON 파일:**
```json
{
  "auth": {
    "SignUp": {
      "form": {
        "placeholder": "이메일을 입력하세요"
      }
    }
  }
}
```

**컴포넌트:**
```typescript
const t = useTranslations('auth.SignUp');
return <input placeholder={t('form.placeholder')} />;
```

### 변수 삽입 (Interpolation)

**JSON 파일:**
```json
{
  "welcome": "안녕하세요, {name}님!",
  "itemCount": "{count}개의 항목"
}
```

**컴포넌트:**
```typescript
const t = useTranslations('common');

t('welcome', {name: '홍길동'});  // "안녕하세요, 홍길동님!"
t('itemCount', {count: 5});       // "5개의 항목"
```

### 복수형 처리

**기수 복수형 (plural):**
```json
{
  "followers": "팔로워 {count, plural, =0 {없음} =1 {# 명} other {# 명}}"
}
```

```typescript
t('followers', {count: 0});  // "팔로워 없음"
t('followers', {count: 1});  // "팔로워 1 명"
t('followers', {count: 5});  // "팔로워 5 명"
```

**서수 복수형 (selectordinal):**
```json
{
  "birthday": "{year, selectordinal, one {#번째} other {#번째}} 생일"
}
```

### 서버 컴포넌트 번역

App Router에서는 서버 컴포넌트에서 `getTranslations` 또는 `createTranslator`를 사용해 빌드 타임 혹은 요청 시점에 번역 문자열을 생성합니다.

```tsx
// app/[locale]/forum/list/page.tsx (Server Component)
import {getTranslations} from 'next-intl/server';

export default async function ForumListPage() {
  const t = await getTranslations('forum');

  return (
    <section>
      <h1 className="text-3xl font-bold">{t('title')}</h1>
    </section>
  );
}
```

```ts
// lib/forum-metadata.ts
import {createTranslator} from 'next-intl';

export async function createForumSeo(locale: string) {
  const translator = await createTranslator({locale, namespace: 'forum'});
  return {
    title: translator('seo.title'),
    description: translator('seo.description'),
  };
}
```

> `createTranslator`는 `generateMetadata`, `generateStaticParams`, API Route 등 React 외부 컨텍스트에서 번역이 필요할 때 유용합니다.

### Rich 텍스트 & React 요소 번역

```json
// messages/ko.json
{
  "auth": {
    "terms": "약관에 <strong>동의</strong>했습니다."
  }
}
```

```tsx
const t = useTranslations('auth');

return t.rich('terms', {
  strong: (chunk) => <strong className="text-primary">{chunk}</strong>,
});
```

리치 텍스트 번역 시 문자열 일부분을 React 요소로 치환할 수 있으며, 공식 문서에서는 `t.rich`를 사용해 XSS 위험 없이 안전하게 처리할 것을 권장합니다.

### Provider 메시지 직접 접근

```tsx
import {useMessages} from 'next-intl';

const messages = useMessages();
const authPlaceholders = messages?.auth?.placeholders;
```

`useMessages`는 Provider가 전달한 전체 메시지 객체를 반환합니다. 공통 레이아웃에서 placeholder, SEO 텍스트 등을 재사용해야 할 때 활용합니다.

---

## 8. 숫자 포맷팅

### useFormatter Hook

```typescript
import {useFormatter} from 'next-intl';

export default function Component() {
  const format = useFormatter();

  // 통화 표시
  format.number(499.9, {style: 'currency', currency: 'USD'});
  // 영어: "$499.90"
  // 한국어: "US$499.90"

  // 백분율
  format.number(0.85, {style: 'percent'});
  // "85%"

  // 소수점 자릿수
  format.number(1234.5678, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  // 영어: "1,234.57"
  // 한국어: "1,234.57"
}
```

### 글로벌 포맷 사용

**i18n/request.ts에서 포맷 정의:**
```typescript
export default getRequestConfig(async ({locale}) => {
  return {
    locale,
    messages: (await import(`../../messages/${locale}.json`)).default,
    formats: {
      number: {
        price: {
          style: 'currency',
          currency: 'KRW'
        }
      }
    }
  };
});
```

**컴포넌트에서 사용:**
```typescript
format.number(49900, 'price');  // "₩49,900"
```

---

## 9. 날짜/시간 포맷팅

### dateTime() 함수

```typescript
import {useFormatter} from 'next-intl';

export default function Component() {
  const format = useFormatter();
  const date = new Date('2025-10-31T15:30:00');

  // 기본 포맷
  format.dateTime(date, {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
  // 영어: "Oct 31, 2025"
  // 한국어: "2025년 10월 31일"

  // 시간 포함
  format.dateTime(date, {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric'
  });
  // 한국어: "2025년 10월 31일 오후 3:30"
}
```

### relativeTime() 함수

```typescript
import {useFormatter} from 'next-intl';

export default function Component() {
  const format = useFormatter();
  const now = new Date();
  const twoHoursAgo = new Date(now.getTime() - 2 * 60 * 60 * 1000);

  format.relativeTime(twoHoursAgo, now);
  // 영어: "2 hours ago"
  // 한국어: "2시간 전"

  // 특정 단위 지정
  format.relativeTime(twoHoursAgo, {unit: 'day'});
  // "0 days ago"
}
```

### useNow Hook (자동 업데이트)

```typescript
import {useFormatter, useNow} from 'next-intl';

export default function Component() {
  const format = useFormatter();
  const now = useNow({
    updateInterval: 1000 * 60  // 1분마다 업데이트
  });

  const postDate = new Date('2025-10-31T14:00:00');

  return <span>{format.relativeTime(postDate, now)}</span>;
  // 자동으로 "1시간 전" → "2시간 전"으로 업데이트됨
}
```

---

## 10. 리스트 포맷팅

### list() 함수

```typescript
import {useFormatter} from 'next-intl';

export default function Component() {
  const format = useFormatter();
  const items = ['HTML', 'CSS', 'JavaScript'];

  // 연결형 (and)
  format.list(items, {type: 'conjunction'});
  // 영어: "HTML, CSS, and JavaScript"
  // 한국어: "HTML, CSS 및 JavaScript"

  // 선택형 (or)
  format.list(items, {type: 'disjunction'});
  // 영어: "HTML, CSS, or JavaScript"
  // 한국어: "HTML, CSS 또는 JavaScript"
}
```

### React 요소와 함께 사용

```typescript
const users = [
  <Link href="/users/1">홍길동</Link>,
  <Link href="/users/2">김철수</Link>,
  <Link href="/users/3">이영희</Link>
];

format.list(users);
// "홍길동, 김철수 및 이영희" (각각 링크로 렌더링)
```

---

## 7. 라우팅 설정

### i18n/routing.ts

```typescript
import {defineRouting} from 'next-intl/routing';

export const routing = defineRouting({
  locales: ['en', 'ko', 'ja', 'zh'],
  defaultLocale: 'ko',
  localePrefix: 'as-needed'  // 기본 locale은 접두사 제거
});
```

### navigation.ts

```typescript
import {createNavigation} from 'next-intl/navigation';
import {routing} from './i18n/routing';

export const {Link, redirect, usePathname, useRouter} =
  createNavigation(routing);
```

### Link 컴포넌트 사용

```typescript
import {Link} from '@/navigation';

export default function Component() {
  return (
    <>
      {/* 현재 locale 유지 */}
      <Link href="/forum/list">포럼</Link>

      {/* locale 변경 */}
      <Link href="/forum/list" locale="en">Forum</Link>
    </>
  );
}
```

### useRouter Hook

```typescript
import {useRouter} from '@/navigation';

export default function Component() {
  const router = useRouter();

  const handleClick = () => {
    router.push('/forum/list');  // locale 자동 포함
  };

  return <button onClick={handleClick}>이동</button>;
}
```

### Locale Prefix 전략

**1. `localePrefix: 'always'` (기본값)**
- 모든 경로에 locale 접두사 포함
- 예: `/ko/forum/list`, `/en/forum/list`

**2. `localePrefix: 'as-needed'` (권장)**
- 기본 locale은 접두사 없음
- 다른 locale은 접두사 포함
- 예: `/forum/list` (한국어), `/en/forum/list` (영어)

**3. `localePrefix: 'never'`**
- URL에 locale 표시 안 함
- domain 기반 또는 cookie 기반 locale 결정 시 사용

### Locale Detection

미들웨어가 자동으로 locale을 감지합니다:
1. URL의 locale 접두사
2. `accept-language` 헤더
3. 쿠키 (`NEXT_LOCALE`)

```typescript
// middleware.ts
import createMiddleware from 'next-intl/middleware';
import {routing} from './i18n/routing';

export default createMiddleware(routing);

export const config = {
  matcher: ['/((?!api|_next|.*\\..*).*)']
};
```

### Pathnames 매핑

`routing` 객체의 `pathnames` 옵션을 사용하면 각 locale별로 안정적인 경로를 유지하거나 언어마다 다른 URL을 제공할 수 있습니다. 공식 문서는 SEO 친화적인 다국어 URL을 위해 미리 선언하는 것을 권장합니다.

```ts
// src/i18n/routing.ts
export const routing = defineRouting({
  locales: ['en', 'ko', 'ja', 'zh'],
  defaultLocale: 'ko',
  localePrefix: 'as-needed',
  pathnames: {
    '/forum/list': {
      ko: '/forum/list',
      en: '/forum/list',
      ja: '/forum/list',
      zh: '/forum/list',
    },
    '/auth/login': {
      ko: '/auth/login',
      en: '/auth/login',
      ja: '/auth/login',
      zh: '/auth/login',
    },
  },
});
```

향후 `/menu` → `/メニュー` 같은 언어별 맞춤 경로가 필요할 때는 해당 경로만 별도로 변경하면 됩니다.

### localeDetection & 리다이렉트 제어

```ts
export const routing = defineRouting({
  // ...
  localeDetection: true,
  redirects: {
    '/': 'home', // pathnames.home를 기준으로 리다이렉트
  },
});
```

- `localeDetection`을 `false`로 설정하면 자동 감지를 비활성화하고, `/ko`, `/en` 등 명시적 prefix만 허용합니다.
- `redirects` 옵션을 사용하면 루트 경로를 특정 locale 페이지로 강제 이동시킬 수 있습니다.
- 멀티 도메인이 필요하다면 `domains` 배열에 `{domain, defaultLocale, locales}`를 선언합니다.

---

## 11. 본 프로젝트 적용 가이드

### 8.1 현재 프로젝트 구조
본 프로젝트(Vibe)는 다음과 같은 구조를 가지고 있습니다:
```
app/
  ├── forum/list/page.tsx
  ├── chat/room/page.tsx
  ├── auth/login/page.tsx
  └── layout.tsx
```

### 8.2 다국어 적용 단계별 가이드

#### 1단계: 디렉토리 구조 변경

**변경 전:**
```
app/
  └── forum/list/page.tsx
```

**변경 후:**
```
app/
  ├── [locale]/
  │   └── forum/list/page.tsx
  └── navigation.ts
```

#### 2단계: 번역 파일 생성

**messages/ko.json:**
```json
{
  "common": {
    "submit": "전송",
    "cancel": "취소",
    "loading": "로딩 중..."
  },
  "forum": {
    "title": "포럼",
    "createPost": "글쓰기",
    "category": "카테고리",
    "categories": {
      "community": "커뮤니티",
      "qna": "질문과답변",
      "news": "뉴스",
      "market": "회원장터"
    },
    "noPost": "게시글이 없습니다",
    "firstPost": "첫 번째 게시글을 작성해보세요!"
  },
  "auth": {
    "login": "로그인",
    "signup": "회원가입",
    "email": "이메일",
    "password": "비밀번호"
  }
}
```

**messages/en.json:**
```json
{
  "common": {
    "submit": "Submit",
    "cancel": "Cancel",
    "loading": "Loading..."
  },
  "forum": {
    "title": "Forum",
    "createPost": "Write",
    "category": "Category",
    "categories": {
      "community": "Community",
      "qna": "Q&A",
      "news": "News",
      "market": "Marketplace"
    },
    "noPost": "No posts yet",
    "firstPost": "Write the first post!"
  },
  "auth": {
    "login": "Log in",
    "signup": "Sign up",
    "email": "Email",
    "password": "Password"
  }
}
```

#### 3단계: 컴포넌트에서 번역 사용

**변경 전 (app/forum/list/page.tsx):**
```typescript
<h1 className="text-3xl font-bold">포럼</h1>
<Button onClick={handleCreatePost}>
  <MessageSquarePlus className="h-4 w-4" />
  글쓰기
</Button>
```

**변경 후 (app/[locale]/forum/list/page.tsx):**
```typescript
import {useTranslations} from 'next-intl';

export default function ForumListPage() {
  const t = useTranslations('forum');

  return (
    <>
      <h1 className="text-3xl font-bold">{t('title')}</h1>
      <Button onClick={handleCreatePost}>
        <MessageSquarePlus className="h-4 w-4" />
        {t('createPost')}
      </Button>
    </>
  );
}
```

#### 4단계: 카테고리 목록 다국어화

**app.config.ts 수정:**
```typescript
// 변경 전
export const FORUM_CATEGORIES = [
  { value: "community", label: "커뮤니티" },
  { value: "qna", label: "질문과답변" },
  // ...
];

// 변경 후
export const FORUM_CATEGORIES = [
  { value: "community" },
  { value: "qna" },
  { value: "news" },
  { value: "market" },
] as const;
```

**컴포넌트에서 사용:**
```typescript
const t = useTranslations('forum.categories');

{FORUM_CATEGORIES.map((category) => (
  <SelectItem key={category.value} value={category.value}>
    {t(category.value)}
  </SelectItem>
))}
```

#### 5단계: 날짜/시간 다국어화

**게시글 작성 시간 표시:**
```typescript
const format = useFormatter();
const now = useNow({updateInterval: 60000});  // 1분마다 업데이트

{posts.map((post) => (
  <div key={post.postId}>
    <h3>{post.title}</h3>
    <span>{format.relativeTime(new Date(post.createdAt), now)}</span>
  </div>
))}
```

#### 6단계: 언어 전환 UI 추가

**components/language-switcher.tsx:**
```typescript
'use client';

import {useLocale} from 'next-intl';
import {useRouter, usePathname} from '@/navigation';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

const languages = [
  {code: 'ko', name: '한국어'},
  {code: 'en', name: 'English'},
  {code: 'ja', name: '日本語'},
  {code: 'zh', name: '中文'}
];

export function LanguageSwitcher() {
  const locale = useLocale();
  const router = useRouter();
  const pathname = usePathname();

  const handleChange = (newLocale: string) => {
    router.replace(pathname, {locale: newLocale});
  };

  return (
    <Select value={locale} onValueChange={handleChange}>
      <SelectTrigger>
        <SelectValue />
      </SelectTrigger>
      <SelectContent>
        {languages.map((lang) => (
          <SelectItem key={lang.code} value={lang.code}>
            {lang.name}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}
```

#### 7단계: 라우팅 및 미들웨어 연결

1. `src/i18n/routing.ts`에 `defineRouting`을 정의하고 `locales`, `defaultLocale`, `localePrefix`, `pathnames`를 선언합니다.
2. `app/navigation.ts`에서 `createNavigation(routing)`으로 `Link`, `useRouter`, `usePathname`를 재정의해 locale-aware 네비게이션을 사용합니다.
3. 루트에 `middleware.ts`를 생성하여 `createMiddleware(routing)`을 반환합니다. `matcher`는 `/((?!api|_next|.*\\..*).*)`로 설정해 정적 자산과 API를 제외합니다.

> 공식 문서의 Routing · Setup 예제를 그대로 적용하면 됩니다. 미들웨어는 Vercel Edge에서 실행되므로 가벼운 로직만 유지합니다.

#### 8단계: 포맷 및 기본값 중앙 관리

- `i18n/request.ts`의 `getRequestConfig`에서 `formats.number`, `formats.dateTime`, `formats.list` 등을 정의해 재사용 가능한 프리셋을 만듭니다.
- `defaultTranslationValues`를 사용하면 `{name}` 같은 placeholder의 기본값을 지정할 수 있어 누락 시에도 앱이 깨지지 않습니다.
- `timeZone`, `now` 옵션을 통해 날짜/시간 관련 계산을 일관되게 유지합니다.

### 8.3 우선순위별 적용 순서

**Phase 1: 기본 UI 텍스트 (필수)**
- 공통 버튼 (전송, 취소, 저장 등)
- 네비게이션 메뉴
- 에러 메시지

**Phase 2: 주요 기능 (권장)**
- 게시판 카테고리
- 로그인/회원가입 폼
- 프로필 페이지

**Phase 3: 포맷팅 (선택)**
- 날짜/시간 상대 표시
- 숫자 통화 표시
- 리스트 포맷팅

### 8.4 주의사항

1. **하드코딩된 텍스트 금지**
   - ❌ `<button>전송</button>`
   - ✅ `<button>{t('common.submit')}</button>`

2. **변수는 번역 파일에서 처리**
   - ❌ `{count}개의 게시글`
   - ✅ `{t('forum.postCount', {count})}`

3. **복수형 처리 활용**
   - ❌ `{count === 1 ? '게시글' : '게시글들'}`
   - ✅ `{t('forum.posts', {count})}`

4. **날짜는 항상 포맷팅**
   - ❌ `new Date(post.createdAt).toLocaleDateString()`
   - ✅ `format.dateTime(new Date(post.createdAt), {...})`

### 8.5 성능 최적화

1. **Server Components에서 번역 로드**
   ```typescript
   import {getTranslations} from 'next-intl/server';

   export default async function Page() {
     const t = await getTranslations('forum');
     // ...
   }
   ```

2. **클라이언트에서는 필요한 네임스페이스만**
   ```typescript
   const t = useTranslations('forum');  // 전체 메시지가 아닌 forum만
   ```

3. **공통 번역은 레이아웃에서 제공**
   ```typescript
   // app/[locale]/layout.tsx
   const messages = await getMessages();
   return (
     <NextIntlClientProvider messages={pick(messages, ['common'])}>
       {children}
     </NextIntlClientProvider>
   );
   ```

### 8.6 핵심 컴포넌트 적용 예시

- **Topbar (`components/topbar.tsx`)**
  - `useTranslations('navigation')`으로 포럼/채팅/사용자 메뉴 라벨을 치환합니다.
  - 로그인 상태별 버튼 텍스트(`로그인`, `회원가입`, `프로필 수정`)를 `auth`, `profile` 네임스페이스로 분리합니다.
  - 드롭다운 또는 모바일 메뉴에 `LanguageSwitcher`를 배치해 locale 전환을 제공합니다.

  ```tsx
  const tNav = useTranslations('navigation');

  <Button variant="ghost" size="sm" asChild>
    <Link href="/forum/list">
      <LayoutGrid className="h-4 w-4 mr-2" />
      {tNav('forum')}
    </Link>
  </Button>
  ```

- **메뉴 페이지 (`app/menu/page.tsx`)**
  - `useTranslations('menu')`로 버튼 레이블과 설명 문구를 구성합니다.
  - 회원 정보 카드에서 `format.list`를 사용해 사용자 역할 등을 자연어로 병기할 수 있습니다.
  - 로그아웃 버튼 알림 문구는 `t('menu.logout.confirm')` 같이 별도 키로 관리합니다.

- **포럼 & 채팅 페이지 (`app/[locale]/forum/**`, `app/[locale]/chat/**`)**
  - 서버 컴포넌트에서 `getTranslations('forum')` 또는 `getTranslations('chat')`로 SEO 텍스트와 타이틀을 설정합니다.
  - 게시글/메시지 타임스탬프에 `format.relativeTime`을 적용하고, 숫자 통계(조회수·좋아요)는 `format.number`를 사용합니다.

- **공유 구성 (`app/app.config.ts`, `app/config/forum.ts` 등)**
  - `FORUM_CATEGORIES`처럼 label을 가진 상수는 `value`만 유지하고, 표시 문자열은 `t('forum.categories.community')`로 불러옵니다.
  - Validation/에러 메시지는 `messages/common/errors.json`과 같이 별도 파일에 묶어 재사용합니다.

### 8.7 테스트 및 QA 체크리스트

- `/`, `/forum/list`, `/auth/login`, `/menu`, `/admin`을 각 locale로 전환하며 경로와 텍스트가 올바르게 렌더링되는지 확인합니다.
- Locale 전환 시 쿼리스트링과 해시값이 유지되는지, `router.replace`가 예상대로 동작하는지 검증합니다.
- 숫자·날짜 포맷이 locale별 기대값(예: `₩49,900`, `2025년 10월 31일`, `2시간 전`)과 일치하는지 샘플 데이터를 기준으로 확인합니다.
- 미들웨어가 인증 여부와 무관하게 동일한 locale 정책을 적용하는지, 보호 페이지(`profile`, `chat/room`, `admin/*`)가 올바르게 리다이렉트되는지 확인합니다.
- 메시지 누락 시 fallback(`defaultTranslationValues`, 영어 기본 메시지)이 노출되는지 확인하고, 브라우저 콘솔에 경고가 없는지 점검합니다.

---

## Quick Reference

### 핵심 설정

- **라우팅 전략**: `localePrefix: 'never'` (Cookie-based)
- **로케일 감지 순서**:
  1. NEXT_LOCALE 쿠키 (최우선)
  2. Accept-Language 헤더
  3. defaultLocale('ko') 폴백
- **URL 형식**: 항상 고정 (예: `/forum/list`, `/about-us`)

### 주요 파일

| 파일 | 설명 | 핵심 설정 |
|------|------|-----------|
| `i18n/routing.ts` | 라우팅 설정 | `localePrefix: 'never'` |
| `middleware.ts` | 자동 로케일 감지 | `createMiddleware(routing)` |
| `app/layout.tsx` | 레이아웃 설정 | `getLocale()`, `getMessages()` |
| `app/actions/set-locale.ts` | 쿠키 설정 서버 액션 | `cookies().set('NEXT_LOCALE')` |
| `components/language-switcher.tsx` | 언어 전환 UI | `setLocale()` 호출 |
| `messages/{locale}.json` | 번역 파일 | JSON 형식 |

### 동작 방식

**첫 방문 시:**
1. 미들웨어가 Accept-Language 감지
2. 해당 언어의 메시지 로드
3. 페이지 렌더링

**언어 전환 시:**
1. 사용자가 언어 스위처에서 선택
2. 서버 액션으로 NEXT_LOCALE 쿠키 설정
3. `redirect()`로 페이지 새로고침
4. 미들웨어가 쿠키 읽고 새 언어 적용

**이후 방문 시:**
1. 미들웨어가 NEXT_LOCALE 쿠키 확인
2. 저장된 언어 사용
3. 사용자가 선택한 언어 유지

### URL 예시

| 언어 | URL | 쿠키 | 표시 |
|------|-----|------|------|
| 한국어 | `/forum/list` | `NEXT_LOCALE=ko` | "포럼", "글쓰기" |
| 영어 | `/forum/list` | `NEXT_LOCALE=en` | "Forum", "Write" |
| 일본어 | `/forum/list` | `NEXT_LOCALE=ja` | "フォーラム", "書く" |
| 중국어 | `/forum/list` | `NEXT_LOCALE=zh` | "论坛", "写" |

### 핵심 함수

**번역:**
```typescript
// 클라이언트 컴포넌트
const t = useTranslations('namespace');
t('key')  // "번역된 텍스트"

// 서버 컴포넌트
const t = await getTranslations('namespace');
t('key')  // "번역된 텍스트"
```

**포맷팅:**
```typescript
const format = useFormatter();

// 숫자
format.number(49900, {style: 'currency', currency: 'KRW'})  // "₩49,900"

// 날짜
format.dateTime(new Date(), {year: 'numeric', month: 'short', day: 'numeric'})

// 상대 시간
const now = useNow();
format.relativeTime(pastDate, now)  // "2시간 전"

// 리스트
format.list(['A', 'B', 'C'], {type: 'conjunction'})  // "A, B 및 C"
```

**언어 전환:**
```typescript
import {setLocale} from '@/app/actions/set-locale';

// 현재 페이지 유지하면서 언어 전환
const currentPath = window.location.pathname + window.location.search + window.location.hash;
await setLocale('en', currentPath);
```

### 트러블슈팅

**쿠키가 설정되지 않을 때:**
1. 서버 액션(`app/actions/set-locale.ts`) 사용 확인
2. `redirect()` 호출 확인
3. 브라우저 개발자 도구 → Application → Cookies에서 NEXT_LOCALE 확인

**번역이 표시되지 않을 때:**
1. `messages/{locale}.json` 파일 존재 확인
2. JSON 파일 형식 오류 확인
3. 네임스페이스와 키 경로 확인 (예: `t('forum.title')`)

**미들웨어가 작동하지 않을 때:**
1. `middleware.ts` 파일이 프로젝트 루트에 있는지 확인
2. `matcher` 설정이 올바른지 확인
3. `i18n/routing.ts` import 경로 확인

### 주의사항

- ✅ **서버 액션 사용**: 쿠키 설정 시 반드시 서버 액션 사용
- ✅ **UTF-8 인코딩**: 모든 번역 파일 UTF-8로 저장
- ✅ **하드코딩 금지**: 모든 텍스트는 번역 파일로 관리
- ❌ **`document.cookie` 직접 조작 금지**: 엣지 환경에서 누락 위험
- ❌ **URL에 locale 포함 금지**: `localePrefix: 'never'` 사용

---

---

## 12. 본 프로젝트 실제 구현 내역

### 12.1 구현 개요

**2025년 10월 31일 기준 - Vibe 프로젝트 다국어 구현 완료**

본 프로젝트는 Next-Intl 4.4.0을 사용하여 Cookie-based 다국어 시스템을 구현했습니다. URL에 로케일 접두사 없이(`localePrefix: 'never'`) 쿠키만으로 언어를 관리하는 방식을 채택했습니다.

**핵심 특징:**
- ✅ **app/[locale] 폴더 구조 사용 안 함** - localePrefix: 'never' 전략에 맞춰 기존 폴더 구조 유지
- ✅ **수동 locale 감지** - i18n/request.ts와 app/layout.tsx에서 cookies와 headers 직접 읽기
- ✅ **Next.js 16 호환** - `await cookies()` API 사용
- ✅ **4개 언어 지원** - 영어(en), 한국어(ko), 중국어(zh), 일본어(ja)
- ✅ **언어 전환 UI** - Left Sidebar와 Menu 페이지에 언어 스위처 배치

### 12.2 구현된 파일 구조

```
vibe/
├── i18n/
│   ├── request.ts              # ⭐ 수동 locale 감지 (쿠키 + Accept-Language)
│   └── routing.ts              # localePrefix: 'never' 설정
├── middleware.ts               # ⭐ 간소화된 미들웨어 (직접 export)
├── app/
│   ├── layout.tsx              # ⭐ 수동 locale 감지 및 NextIntlClientProvider
│   ├── app.config.ts           # LOCALES, DEFAULT_LOCALE, LOCALE_INFO
│   └── actions/
│       └── set-locale.ts       # ⭐ Next.js 16 호환 쿠키 설정
├── components/
│   ├── language-switcher.tsx   # 언어 전환 드롭다운
│   └── left-sidebar.tsx        # 언어 스위처 포함
├── messages/
│   ├── en.json                 # 영어 번역 (~100 키)
│   ├── ko.json                 # 한국어 번역
│   ├── zh.json                 # 중국어 번역
│   └── ja.json                 # 일본어 번역
└── next.config.ts              # createNextIntlPlugin 필수 적용
```

### 12.3 핵심 구현 코드

#### i18n/request.ts (수동 locale 감지)

**⚠️ 중요**: 이 파일이 전체 시스템의 핵심입니다. localePrefix: 'never'를 사용할 때는 `locale` 파라미터를 사용하지 않고, 직접 쿠키와 헤더를 읽어야 합니다.

```typescript
import {getRequestConfig} from 'next-intl/server';
import {cookies, headers} from 'next/headers';
import {DEFAULT_LOCALE, LOCALES} from '@/app/app.config';

// Next-Intl 요청 설정
// i18n routing 없이 쿠키 기반으로 locale을 결정합니다
export default getRequestConfig(async () => {
  // 쿠키에서 locale 읽기 (Next.js 16+: await 필요)
  const cookieStore = await cookies();
  let locale = cookieStore.get('NEXT_LOCALE')?.value;

  // 쿠키가 없으면 Accept-Language 헤더에서 읽기
  if (!locale) {
    const headersList = await headers();
    const acceptLanguage = headersList.get('accept-language');

    if (acceptLanguage) {
      // Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
      // 첫 번째 언어 코드 추출
      const preferredLocale = acceptLanguage.split(',')[0].split('-')[0];

      // 지원하는 언어인지 확인
      if (LOCALES.includes(preferredLocale as any)) {
        locale = preferredLocale;
      }
    }
  }

  // 여전히 locale이 없으면 기본값 사용
  const safeLocale = locale || DEFAULT_LOCALE;

  return {
    locale: safeLocale,
    messages: (await import(`../messages/${safeLocale}.json`)).default
  };
});
```

**핵심 포인트:**
- ❌ `async ({locale})` 파라미터 사용 안 함 (undefined가 됨)
- ✅ `await cookies()` 직접 호출 (Next.js 16)
- ✅ `await headers()` 직접 호출
- ✅ `locale` 필드를 반환 객체에 포함

#### middleware.ts (간소화된 미들웨어)

```typescript
import createMiddleware from 'next-intl/middleware';
import {routing} from './i18n/routing';

export default createMiddleware(routing);

export const config = {
  matcher: ['/((?!api|_next|_vercel|.*\\..*).*)']
};
```

**핵심 포인트:**
- ✅ 복잡한 async 래퍼 없이 직접 export
- ✅ routing 객체만 전달
- ✅ 정적 파일/API 제외하는 matcher 설정

#### i18n/routing.ts (localePrefix: 'never')

```typescript
import {defineRouting} from 'next-intl/routing';
import {LOCALES, DEFAULT_LOCALE} from '@/app/app.config';

export const routing = defineRouting({
  locales: LOCALES,
  defaultLocale: DEFAULT_LOCALE,
  localePrefix: 'never'  // ⭐ 핵심: URL에 로케일 접두어 절대 안 붙임
});
```

**핵심 포인트:**
- ✅ `localePrefix: 'never'` - URL은 항상 `/forum/list` 형태
- ✅ 쿠키가 로케일의 단일 소스가 됨

#### app/layout.tsx (수동 locale 감지)

```typescript
import { NextIntlClientProvider } from 'next-intl';
import { getMessages } from 'next-intl/server';
import { cookies, headers } from 'next/headers';
import { LOCALES, DEFAULT_LOCALE, type Locale } from "./app.config";

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // ⭐ i18n/request.ts와 동일한 로직으로 locale 감지
  const cookieStore = await cookies();
  let locale = cookieStore.get('NEXT_LOCALE')?.value as Locale;

  // 쿠키가 없으면 Accept-Language 헤더에서 읽기
  if (!locale) {
    const headersList = await headers();
    const acceptLanguage = headersList.get('accept-language');

    if (acceptLanguage) {
      const preferredLocale = acceptLanguage.split(',')[0].split('-')[0];
      if (LOCALES.includes(preferredLocale as any)) {
        locale = preferredLocale as Locale;
      }
    }
  }

  // 여전히 locale이 없으면 기본값 사용
  const safeLocale = locale || DEFAULT_LOCALE;

  // i18n/request.ts에서 제공하는 messages 가져오기
  const messages = await getMessages();

  return (
    <html lang={safeLocale}>
      <body>
        {/* Next-Intl Provider: 모든 하위 컴포넌트에서 번역 사용 가능 */}
        <NextIntlClientProvider locale={safeLocale} messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
```

**핵심 포인트:**
- ✅ i18n/request.ts와 동일한 locale 감지 로직 사용
- ✅ `getMessages()` 사용 (i18n/request.ts에서 정의한 방식)
- ✅ locale과 messages를 NextIntlClientProvider에 전달

#### app/actions/set-locale.ts (Next.js 16 호환)

```typescript
'use server';

import {cookies} from 'next/headers';
import {redirect} from 'next/navigation';

// 서버 액션: 사용자가 선택한 언어를 쿠키에 저장
// 이 함수는 클라이언트 컴포넌트에서 호출되어 언어를 변경합니다
//
// @param locale - 변경할 언어 코드 ('en', 'ko', 'zh', 'ja')
// @param redirectTo - 리다이렉트할 경로 (현재 페이지 경로)
export async function setLocale(locale: string, redirectTo: string) {
  // NEXT_LOCALE 쿠키에 선택한 언어 저장
  // ⭐ Next.js 16+: cookies()는 Promise를 반환하므로 await 필요
  const cookieStore = await cookies();
  cookieStore.set('NEXT_LOCALE', locale, {
    path: '/',                      // 모든 경로에서 접근 가능
    maxAge: 60 * 60 * 24 * 365,     // 1년간 유지
    sameSite: 'lax',                // CSRF 보호
    secure: process.env.NODE_ENV === 'production'  // 프로덕션에서는 HTTPS만
  });

  // 페이지 새로고침으로 변경된 언어 적용
  // redirect()를 사용하면 서버에서 새로운 언어로 페이지를 다시 렌더링합니다
  redirect(redirectTo);
}
```

**핵심 포인트:**
- ✅ `await cookies()` 사용 (Next.js 16 필수)
- ✅ `redirect()` 호출로 새로고침
- ✅ 쿠키 옵션: path, maxAge, sameSite, secure

#### components/language-switcher.tsx (언어 전환 UI)

```typescript
'use client';

import {useTransition} from 'react';
import {useLocale} from 'next-intl';
import {setLocale} from '@/app/actions/set-locale';
import {LOCALES, LOCALE_INFO, type Locale} from '@/app/app.config';

export function LanguageSwitcher() {
  const currentLocale = useLocale() as Locale;
  const [isPending, startTransition] = useTransition();

  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const nextLocale = event.target.value as Locale;

    // 쿼리스트링과 해시까지 포함해 현재 페이지 유지
    const currentPath = window.location.pathname +
                       window.location.search +
                       window.location.hash;

    // Transition으로 감싸서 부드러운 전환
    startTransition(() => {
      setLocale(nextLocale, currentPath);
    });
  };

  return (
    <select
      value={currentLocale}
      onChange={handleChange}
      disabled={isPending}
      className="w-full px-3 py-2 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-slate-400"
    >
      {LOCALES.map((locale) => (
        <option key={locale} value={locale}>
          {LOCALE_INFO[locale].flag} {LOCALE_INFO[locale].name}
        </option>
      ))}
    </select>
  );
}
```

**핵심 포인트:**
- ✅ `useLocale()` Hook으로 현재 언어 감지
- ✅ `startTransition()` 사용으로 부드러운 전환
- ✅ 쿼리스트링과 해시 유지
- ✅ `isPending` 상태로 로딩 표시

#### app/app.config.ts (언어 설정)

```typescript
// 지원하는 로케일 목록 (영어, 한국어, 중국어, 일본어)
export const LOCALES = ['en', 'ko', 'zh', 'ja'] as const;
export type Locale = typeof LOCALES[number];

// 기본 로케일 (한국어)
export const DEFAULT_LOCALE: Locale = 'ko';

// 로케일 정보 (국기, 이름)
export const LOCALE_INFO: Record<Locale, { flag: string; name: string }> = {
  en: { flag: '🇺🇸', name: 'English' },
  ko: { flag: '🇰🇷', name: '한국어' },
  zh: { flag: '🇨🇳', name: '中文' },
  ja: { flag: '🇯🇵', name: '日本語' },
};
```

### 12.4 번역 파일 구조

**messages/ko.json** (약 100개 키):
```json
{
  "navigation": {
    "home": "홈",
    "forum": "포럼",
    "chat": "채팅",
    "users": "사용자",
    "menu": "메뉴"
  },
  "auth": {
    "login": "로그인",
    "logout": "로그아웃",
    "signup": "회원가입",
    "email": "이메일",
    "password": "비밀번호"
  },
  "buttons": {
    "save": "저장",
    "cancel": "취소",
    "delete": "삭제",
    "edit": "수정",
    "submit": "제출"
  },
  // ... 더 많은 섹션
}
```

**messages/en.json** (동일한 키 구조):
```json
{
  "navigation": {
    "home": "Home",
    "forum": "Forum",
    "chat": "Chat",
    "users": "Users",
    "menu": "Menu"
  },
  "auth": {
    "login": "Log in",
    "logout": "Log out",
    "signup": "Sign up",
    "email": "Email",
    "password": "Password"
  },
  // ... 동일한 구조
}
```

**번역 파일 섹션:**
- `navigation` - 내비게이션 메뉴
- `auth` - 인증 관련
- `buttons` - 공통 버튼
- `common` - 공통 문구
- `sidebar` - 사이드바
- `menu` - 메뉴 페이지
- `forum` - 게시판
- `chat` - 채팅
- `users` - 사용자 목록
- `profile` - 프로필
- `stats` - 통계
- `home` - 홈페이지

### 12.5 언어 전환 흐름

```
사용자가 언어 스위처에서 'English' 선택
  ↓
[클라이언트]
LanguageSwitcher의 handleChange 이벤트 발생
  ↓
setLocale('en', '/current/path') 서버 액션 호출
  ↓
[서버]
const cookieStore = await cookies();
cookieStore.set('NEXT_LOCALE', 'en', {...});
  ↓
redirect('/current/path')
  ↓
[미들웨어 재실행]
createMiddleware(routing) 실행
  ↓
[i18n/request.ts 실행]
const cookieStore = await cookies();
locale = cookieStore.get('NEXT_LOCALE')?.value;  // 'en'
  ↓
messages/en.json 로드
  ↓
[app/layout.tsx 실행]
동일한 로직으로 locale = 'en' 감지
  ↓
<NextIntlClientProvider locale="en" messages={...}>
  ↓
[페이지 렌더링]
모든 t('key') 호출이 영어 번역으로 표시
```

### 12.6 주요 해결 문제

#### 문제 1: 404 오류 (해결됨)
**증상:** 모든 페이지에서 404 Not Found 발생
**원인:** app/[locale] 폴더 구조를 만들려 했으나 localePrefix: 'never'와 충돌
**해결:** app/[locale] 폴더 구조 제거, 수동 locale 감지로 변경

#### 문제 2: "locale undefined" 오류 (해결됨)
**증상:** `Cannot find module '../messages/undefined.json'`
**원인:** i18n/request.ts에서 locale 파라미터가 undefined
**해결:** 파라미터 대신 cookies()와 headers()에서 직접 읽기

#### 문제 3: Next.js 16 cookies() API (해결됨)
**증상:** `cookies().set is not a function`
**원인:** Next.js 16에서 cookies()가 Promise 반환
**해결:** `const cookieStore = await cookies();` 사용

#### 문제 4: next.config.ts 플러그인 제거 시도 (해결됨)
**증상:** `Couldn't find next-intl config file`
**원인:** createNextIntlPlugin이 필요 없다고 판단
**해결:** 플러그인은 localePrefix: 'never'에서도 필수 (복원함)

### 12.7 검증 완료 사항

- ✅ 홈페이지 로딩 성공 (200 OK)
- ✅ 언어 스위처 동작 (Left Sidebar, Menu 페이지)
- ✅ 쿠키 설정 확인 (NEXT_LOCALE)
- ✅ 4개 언어 번역 파일 생성
- ✅ UTF-8 인코딩 검증 완료

### 12.8 남은 작업

다음 작업이 필요합니다:

1. **모든 페이지에 번역 적용**
   - 현재 대부분의 페이지가 하드코딩된 한국어 텍스트 사용
   - `useTranslations()` Hook으로 변환 필요

2. **번역 파일 확장**
   - 현재 약 100개 키 존재
   - 모든 페이지의 텍스트를 번역 파일로 이동

3. **E2E 테스트**
   - 각 언어로 모든 페이지 접속 테스트
   - 언어 전환 후 동작 확인

### 12.9 중요 참고 사항

**⚠️ localePrefix: 'never' 사용 시 필수 규칙:**

1. **app/[locale] 폴더 구조 사용 금지**
   - 기존 폴더 구조 유지 (app/forum/list/page.tsx)
   - ❌ app/[locale]/forum/list/page.tsx 형태로 변경 금지

2. **i18n/request.ts에서 수동 locale 감지**
   - `async ({locale})` 파라미터 사용 안 함
   - `await cookies()`, `await headers()` 직접 호출

3. **app/layout.tsx에서 수동 locale 감지**
   - i18n/request.ts와 동일한 로직 사용
   - `getMessages()` 사용

4. **Next.js 16 호환**
   - 모든 `cookies()` 호출 전에 `await` 사용

5. **createNextIntlPlugin 필수**
   - localePrefix: 'never'에서도 next.config.ts 플러그인 필요

### 12.10 참고 링크

- [본 프로젝트 i18n/request.ts](../i18n/request.ts)
- [본 프로젝트 middleware.ts](../middleware.ts)
- [본 프로젝트 app/layout.tsx](../app/layout.tsx)
- [본 프로젝트 app/actions/set-locale.ts](../app/actions/set-locale.ts)
- [본 프로젝트 components/language-switcher.tsx](../components/language-switcher.tsx)
- [Next-Intl localePrefix 문서](https://next-intl.dev/docs/routing/configuration#locale-prefix)

---

## 참고 자료

- [Next-Intl 공식 문서](https://next-intl.dev/)
- [Next-Intl GitHub](https://github.com/amannn/next-intl)
- [MDN Intl API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
- [Unicode CLDR](http://cldr.unicode.org/) - 언어별 복수형 규칙
